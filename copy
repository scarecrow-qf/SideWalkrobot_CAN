import asyncio
from typing import List

import can
from can.notifier import MessageRecipient

#import CAN_Send
#import Monitor
class Motor_Monitor:
    def __init__(
        self,
        Name,
        CAN_ID,
        CAN_Channel,
    ):
        '''
        Monitor the motors' status
        
        Parameters
        : Name: Nameing the different motors and you can add any information in this parameters
        : CAN_ID: the motors' ID.
        '''
        self.name = Name
        self.CAN_ID = CAN_ID
        self.CAN_Channel = CAN_Channel
        self.Phase_Current = 0
        self.Output_PWM = 0
        self.Commutation_frequency = 0
        self.Count_position = 0
        self.is_PositionControl_Finish: bool = False
        self.Count_Relative_Position = 0
        self.Motor_Speed = 0                            # unit: RPM
        self.LocationContorl_TimeRemaining = 0          # unit: ms
        self.Current = 0                                # unit: A
        self.Voltage = 0                                # unit: V
        self.is_block = 0
        self.Fault_Status = 0

    def GetParameters(self,Recv,Index):
        # Get Phase_Current data
        if Index == '0x2100':
            self.Phase_Current = Recv['Recv_Data']
            print("get Phase_Current")
        if Index == '0x2101':
            self.Output_PWM = Recv['Recv_Data']
            print("get Output_PWM")
        if Index == '0x2102':
            self.Commutation_frequency = Recv['Recv_Data']
            print('get Commutation frequency')
        if Index == '0x2105':
            self.Count_position = Recv['Recv_Data']
            print('get Count position')
        if Index == '0x2106':
            self.is_PositionControl_Finish = Recv['Recv_Data']
            print('get whether position control is finished')
        if Index == '0x2109':
            self.Count_Relative_Position = Recv['Recv_Data']
            print("get the count of relative position")
        if Index == '0x210a':
            self.Motor_Speed = Recv['Recv_Data']
            print('get motor speed')
        if Index == '0x210b':
            self.LocationContorl_TimeRemaining = Recv['Recv_Data']
            print('get tune remaining')
        if Index == '0x210c':
            self.Current = Recv['Recv_Data']
            print('get current')
        if Index == '0x210d':
            self.Voltage = Recv['Recv_Data']
            print("get voltage")
            print(Recv['Recv_Data'])
        if Index == '0x2111':
            self.is_block = Recv['Recv_Data']
            print('get is block')
        if Index == '0x2112':
            self.Fault_Status = Recv['Recv_Data']
            print('Fault status')

Motor1 = Motor_Monitor('left', 0x602, 'can0')

Receive_Package = {
    'CAN_ID': 0x00,
    'status': 0x00,
    'Index' : 0x00,
    'Index_Sub' : 0x00,
    'Recv_Data' : 0x00,
}
MotorState_dict = {
        0x2100:'Phase_Current',
        0x2101:'Output_PWM',
        0x2102:'Commutation_frequency',
        0x2105:'Count_positon',
        0x2106:'is_PositionControl_Finish',
        0x2109:'Count_Relative_Position',
        0x210A:'Motor_Speed',                            # unit: RPM
        0x210B:'LocationContorl_TimeRemaining',          # unit: ms
        0x210C:'Current',                                # unit: A
        0x210D:'Voltage',                                # unit: V
        0x2111:'is_block',
        0x2112:'Fault_Status'
}

def Receive(CAN_Channel):
    '''
    Author: Liu Yuxiang 
    Time: 2022.10.13
    Basic description
    : waiting for recevice CAN package.
    Parameter 
    : CAN_channel: which channel rev CAN packages. 
    '''
    # rev information
    canx = can.interface.Bus(channel = CAN_Channel, bustype = 'socketcan')

    '''    
    can_filter = [{"can_id": 0x582, "can_mask": 0xffffffff}]
    canx.set_filters(can_filter)
    '''

    '''
    loop the canx, recv the message like a listener
    '''

    for msg in canx:      
        print(msg)


def Unpack_Packages(msg) -> Receive_Package:
    # unpack rev packages
        Receive_Package['CAN_ID'] = hex(msg.arbitration_id)
        '''
        数据字节 0 状态码
        数据字节 1-2 对象字典索引号，低字节在前
        数据字节 3 对象字典子索引号
        数据字节 4-7 读取的数据或传送中止代码，低字节在前
        '''
        Receive_Package['status'] = hex(msg.data[0])
        Receive_Package['Index'] =  hex(msg.data[1] + ( msg.data[2] << 8))
        Receive_Package['Index_Sub'] = hex(msg.data[3])
        Receive_Package['Recv_Data'] = hex(msg.data[4] + (msg.data[5]<<8) + (msg.data[6]<<8) + (msg.data[7]<<8))
        print(Receive_Package)

        return Receive_Package


def Read_Data(CAN_ID, CAN_Channel, Index_num):
    # the data is invalid. Doesn't matter
    CAN_Send.Send_Package(CAN_ID, CAN_Channel, 5, Index_num, [0x00,0x00,0x00,0x00])


def Solve_Message(msg: can.Message) -> None:
    """Regular callback function. Can also be a coroutine."""
    global Motor1
    # You can add any id you want to recv and unpack
    if msg.arbitration_id == 0x582:
        Recv = Unpack_Packages(msg)
        Motor1.GetParameters(Recv,Recv['Index'])   

async def main() -> None:
    """The main function that runs in the loop."""

    with can.Bus(  # type: ignore
         channel="can0", bustype= 'socketcan'
    ) as bus:
        reader = can.AsyncBufferedReader()
        logger = can.Logger("logfile.asc") # Create log file to check the log information

        # 所有异步函数均需要放入到事件队列中
        listeners: List[MessageRecipient] = [
            Solve_Message,  # Callback function
            reader,  # AsyncBufferedReader() listener
            logger,  # Regular Listener object
        ]
   
        # Create Notifier with an explicit loop to use for scheduling of callbacks
        loop = asyncio.get_running_loop()
        # bus: which bus be listened
        # listeners: 每次收到消息将收到的消息传给listener
        # loop: – An asyncio event loop to schedule the listeners in. 
        notifier = can.Notifier(bus, listeners, loop=loop)

        # Start sending first message
        print("Getting messages...")
        for key, value in MotorState_dict.items():
            Read_Data(0x602, 'can0', key)
            # Wait for next message from AsyncBufferedReader
            msg = await reader.get_message()
            # Delay response
            await asyncio.sleep(0.5)

        # Wait for last message to arrive
        await reader.get_message()
        print("Done!")
        print(Motor1.__dict__)

        # Clean-up
        notifier.stop()



def Send_Package(CAN_ID, CAN_Channel, Write_Byte_Num, Index_num, data):
    '''
    基本描述
    Author: Liu Yuxiang 
    Time: 2022.10.13
    description: Contracting bottom interface
    详细描述
    parameter
    :CAN_ID: 0X01-0X7F
    :Write_Byte_Num: from 1 to 5. info: 5 represent you need get data from register
    :Index_num: See the document 
    :data: the msg you need to send 
    '''
    Byte_num_dict = {
    1: 0x2F,
    2: 0x2B,
    3: 0x27,
    4: 0x23,
    5: 0x40, # represent reading data
    }
    if (Write_Byte_Num > 5) or  (Write_Byte_Num < 1):
        print("The Write_Byte_Num is not correct, plz choose 1 to 5./n")
        Write_Byte_Num = 1
    # Put lower byte in front
    Index_num_high =  Index_num & 0xFF
    Index_num_low =   (Index_num >> 8) & 0xFF
    # All data are combined to a list
    data = [Byte_num_dict.get(Write_Byte_Num)] + [Index_num_high,Index_num_low] + [0x00] + data
    msg = can.Message(is_extended_id=False, arbitration_id=CAN_ID, data=data)

    # send can data
    canx = can.interface.Bus(channel = CAN_Channel, bustype = 'socketcan')# socketcan_native
    canx.send(msg)
    print(msg)
    print('\n')
    # Do not close CAN


def Motor_Stop_Control(CAN_ID, CAN_Channel, Stop_Mode):
    '''
    Author: Liu Yuxiang 
    Time: 2022.10.14
    description: Stop motors

    parameter
    CAN_ID: you may have more than one motors, so the CAN_ID must be a list
    Stop_Mode: There are 3 Mode to stop motors
        Normal stop, Emergency stop and Free stop.
        Normal stop: stop by your own set parameters.
        Emergency stop: stop by your own set emergency parameters.
        Free stop: shut down the power and stop motors by resistance 
    '''
    for index,ID in enumerate(CAN_ID):
        if Stop_Mode == 'Normal':
            Send_Package(ID, CAN_Channel, 1, 0x2000, [0x10,0x00,0x00,0x00])
        elif Stop_Mode == 'Emergency':
            Send_Package(ID, CAN_Channel, 1, 0x2000, [0x11,0x00,0x00,0x00])
        elif Stop_Mode == 'Free':
            Send_Package(ID, CAN_Channel, 1, 0x2000, [0x12,0x00,0x00,0x00])

def PWM_Contorl(CAN_ID, CAN_Channel, PWM_Duty_Cycle):
    '''
    Author: Liu Yuxiang 
    Time: 2022.10.13
    description: Control the motor by PWM
    详细描述
    parameter
    :CAN_ID: 0X01-0X7F
    :CAN_channel: (str)can0, can1
    :PWM_Duty_Cycle: -1000 ~ 1000
    '''
    # set mode as PWM control
    Send_Package(CAN_ID, CAN_Channel, 1, 0x2000, [0x00,0x00,0x00,0x00])
    # set PWM_Duty_Cycle
    data = [0x00,0x00,0x00,0x00]
    # Put lower byte in front
    for i in range(0,4):
        digit = i*8
        data[i] = (PWM_Duty_Cycle >> digit) & 0xFF
    # Send message
    Send_Package(CAN_ID, CAN_Channel, 4, 0x2001, data)



def Speed_Contorl(CAN_ID, CAN_Channel, Speed):
    '''
    Author: Liu Yuxiang 
    Time: 2022.10.14
    basic description
    : Control the motor by using speed loop
    parameter
    :Speed: -max speed ~ max speed(-500-500)
    '''
    # set mode as speed control mode
    Send_Package(CAN_ID, CAN_Channel, 1, 0x2000, [0x01,0x00,0x00,0x00])

    # Setting register 0x0077 as 45. Because the number of motor poles is 45.
    # And the parameter can be set by GUI tool, So we do not need set.

    # Setting register 0x200A as 1 which change the motor mode to RPM control mode
    Send_Package(CAN_ID, CAN_Channel, 1, 0x200A, [0x01,0x00,0x00,0x00])
    data = [0x00,0x00,0x00,0x00]
    # Put lower byte in front
    for i in range(0,4):
        digit = i*8
        data[i] = (Speed >> digit) & 0xFF
    # Send message
    Send_Package(CAN_ID, CAN_Channel, 4, 0x2001, data)


def Torque_Contorl(CAN_ID, CAN_Channel, Current):
    '''
    Author: Liu Yuxiang 
    Time: 2022.10.14
    basic description
    :Using the Torque(force) to control motor
    parameter
    :Current: -max current ~ max current(set by youself)
    '''
    # set mode as torque control mode
    Send_Package(CAN_ID, CAN_Channel, 1, 0x2000, [0x02,0x00,0x00,0x00])

    # The actual current is the send_data*0.01(A)
    data = [0x00,0x00,0x00,0x00]
    # Put lower byte in front
    for i in range(0,4):
        digit = i*8
        data[i] = (Current >> digit) & 0xFF
    # Send message
    Send_Package(CAN_ID, CAN_Channel, 4, 0x2001, data)

def Angle_continuity():
    angle = 0
    return angle
def Position_Contorl(CAN_ID, CAN_Channel, Location_Type, Target_Location):
    '''
    Author: Liu Yuxiang 
    Time: 2022.10.14
    basic description
    :Using the position loop to control motor
    parameter
    :Location_Type: two typem, Absolute position and relative position
    :Target_Location: 这个地方文档没写清除，需要测试才知道是怎么样的,应该是根据电机的极来进行计数并控制
    这里需要考虑角度连续化、
    :Target_Location(unit: degree)
    '''
    # set mode as postion control mode
    Send_Package(CAN_ID, CAN_Channel, 1, 0x2000, [0x03,0x00,0x00,0x00])
    # set location control type
    if Location_Type == 'Absolute':
        # set absolute type 
        Send_Package(CAN_ID, CAN_Channel, 1, 0x2002, [0x00,0x00,0x00,0x00])

        '''
        角度连续化需要写的代码
        以及和监控台的代码相比较
        '''
        # set target location
        Send_Package(CAN_ID, CAN_Channel, 1, 0x2003, [0x00,0x00,0x00,0x00])


    # if the type is relative
    else:
        # set absolute type control mode 
        Send_Package(CAN_ID, CAN_Channel, 1, 0x2002, [0x01,0x00,0x00,0x00])

        '''
        角度连续化需要写的代码
        以及和监控台的代码相比较
        '''

        # The actual current is the send_data*0.01(A)
        data = [0x00,0x00,0x00,0x00]
        # Put lower byte in front
        for i in range(0,4):
            digit = i*8
            data[i] = (Target_Location >> digit) & 0xFF
        # Send message
        Send_Package(CAN_ID, CAN_Channel, 4, 0x2001, data)



if __name__ == "__main__":
    asyncio.run(main())
    print("Finish!")
